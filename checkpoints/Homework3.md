Kayden Adams <br>
Homework 3

1. What I Planned To Do <br>
  I'm dividing this up by the weekly goals I had listed in my project proposal. <br>

  a. Basic foundations. I will have a Github repo with an Arcade file. When run, the Arcade file will open Arcade's GUI and display a blank screen (code for this is on Arcade's website) This Github will be linked to TravisCI. I will have a test file with a mock Pytest test that TravisCI will run

  b. All Classes will have the definitions for their methods and attributes defined (I will do the Python equivalent of a header file) Largely, I see myself using this time to familiarize myself with Arcade.
  I will have created a grid-based map that is just a 5x5 square surrounded by walls. I will be using simple squares for this, not cutting out sprites or creating animations.

  c. I will have completed and tested Mover. Additionally, I will have a Player, still represented by a square that the human player will be able to move around the tile room in a grid-locked manner by using the arrow keys.

  d. Monster and MonsterSpawner will be finished. Monsters will each have stats that are set depending on their level. MonsterSpawner will be returning instances of Monsters to the main runner, which will place them in a random valid location around the map. Monsters will move towards the player based on a simple Breadth First Search.

2. What I Actually Accomplished <br>
  Before getting into the specifics of the weekly goals, I wanted to mention that my test suite is lacking. I realized that I don't really know as much about test-driven development as I thought I did. Although I feel fairly comfortable with Pytest, I realized I don't really know how to write non-trivial tests (and tests that won't break TravisCI) for a lot of the functionality I'm creating. I've been testing the game partly through Pytest, but mostly through my old standby, "run it and see if it works." I'll send an e-mail about this too, but any resources you can provide for how to write good tests would be really helpful.

  a. Getting the basic foundations set up was a complete success. It was a bit hard to get TravisCI working with Arcade at first because TravisCI can't deal with GUIs, which Arcade uses. I managed to get around that by moving anything using a GUI into separate functions and having TravisCI run only tests without a GUI.

  b. I fully created the 5x5 grid with walls, which completes a basic DungeonMap class. I also learned a great deal about Arcade. What I didn't do what create header files for everything. I realized as I tried to start header files that I really didn't know enough about how I was going to implement a lot of the project, and I needed to get more familiar with Arcade and what parts of the project would look like before I wrote headers for everything. I'm very glad I decided not to create header because I think I would have felt more locked down into design decisions that I later changed.

  c. A big shift I made around design decisions was creating a super-class for Player and Monster called Actor. This replaces the behavioral classes of Animator, Mover, and likely Attacker as well. I realized that it made more sense, both form a design and a coding perspective, to put this functionality in a super-class that could then be used and overwritten rather than trying to create different types of Mover for Monster vs Player. I do have a square for the Player that can move around in a grid-locked manner. Additionally, the player collides with the walls and any Monsters in the room.

  d. I have a super class of Monster with 3 sub-classes to represent the different types of monsters. Currently, the only difference is the color of the square I'm using to represent them. I also have an BFS AI that the Monsters use to move towards the Player with a bit of wiggling so the Player can possibly escape. What I didn't get done is MonsterSpawner. When I started MonsterSpawner, I realized how little I know about balancing a game. I started getting bogged down in figuring out what the stats for the Monsters and Player would look like at different levels, and how to curve the difficultly so the Player would have a challenge, but still be able to win. I finally decided that I'm going to largely copy the stats from a different dungeon crawler rather than trying to teach myself game design over night. I was lower on time than I wanted to be as well because I needed to do several refactors (switching from x-y coordinates to grid based, updating DungeonMap so it can handle collisions, etc) and everything (MonsterAI especially) just took much longer than I had planned for.

3. What I Had Planned For The Next Deadline <br>
  a. "The Attacker will be finished. Players and Monsters will be able to attack each other and be able to die. If the Player dies, there will be an option to restart the game. If a monster dies, the player should get EXP and be able to level up." <br>
  I'm going to start by finishing MonsterSpawner, but a good part of that is creating monsters with specific stats, which ties into game design and attacking. I still believe creating attack functionality will be doable. However, I definitely under-estimated the time it would take. I now realize that I can't just write code like "damage = atk - def" and have an even remotely balanced game. Not only do I need to do more research into the formulas (for stats, exp-gain leveling up, damage dealing, etc) I'm shamelessly copying from a Pokemon game, but I also need to add way more to the game-play itself. I'll need to add the ability for Monsters and the Player to face different directions based on which way they moved or what buttons the player pressed, plus some kind of visual cue for which way they're facing. I need to add functionality for actually attacking, lower HP, and dying. I need to figure out how to get the game to restart on death. I need to add a turn tracker to do things like slowly restoring the players health, or moving monsters when the player takes an action but not moving them when the player just changes direction or bumps into a wall. I also need some kind of UI to show the player's current health and how much damage is being dealt. As such, I think this is going to take more than the week I previously allotted for it, probably more like 2 or maybe even 3 weeks.

  b. "The next two weeks will be spent on procedural generator for the grid-based dungeon. The first week will largely be learning about how procedural generation works, then getting started on it and getting as far as I can. Then, by the end of the next week, I should have a completed GenerateDungeon. The player should be able to advance to a new floor by stepping on a staircase. A camera should follow the player around so they can only see some of the map." <br>
  To be honest, I'm not sure how feasible this is because I know so little about Procedural Generation. This also involves things like camera controls and changing between levels. Because attack functionality is so important to the core game-play and procedurally generated dungeons are not, I'm thinking I should spend the next 3 weeks on getting direction changing, turn-based combat, attacking, game-play balance, and a basic UI running smoothly before I try to jump into procedural generation. It feels like it would be much easier to hard-code 3 floors and then randomly place the player, monsters, and the stairs around those for variety rather than procedurally generating everything.

  In short, during my next sprint I will complete MonsterSpawner, attack functionality, and a basic UI to show damage being dealt and the Player's current health and exp. I will not do procedural generation unless somehow that all takes way less time than I think it will.

4. Gif of Game Running
  The gif is in this folder, called "DungeonDelveHomework3.gif"
